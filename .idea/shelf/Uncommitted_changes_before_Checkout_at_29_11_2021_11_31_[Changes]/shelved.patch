Index: spec/users/user_spec.rb
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/spec/users/user_spec.rb b/spec/users/user_spec.rb
new file mode 100644
--- /dev/null	(date 1638174467443)
+++ b/spec/users/user_spec.rb	(date 1638174467443)
@@ -0,0 +1,77 @@
+require 'rspec'
+require './spec/spec_helper.rb'
+require_relative '../../lib/users/user'
+
+describe User do
+
+  context "new user" do
+    let (:full_name){ 'Ivan Petroff' }
+    let(:user) { User.new }
+
+    it "makes a user with name Ivan Petrov" do
+      expect(user.full_name).to eql(full_name)
+    end
+  end
+
+  context "new user with full name" do
+    let (:full_name){ 'Ivan Ivanov' }
+    let(:user) { User.new('Ivan', 'Ivanov') }
+
+    it "makes a user with name Ivan Ivanov" do
+      expect(user.full_name).to eql(full_name)
+    end
+  end
+
+  context "full name is string" do
+    let(:user) { User.new('Ivan', 'Ivanov') }
+
+    it "returns string type" do
+      expect(user.full_name).to be_instance_of(String)
+    end
+  end
+
+  context "default user first name " do
+    let (:first_name){ 'Ivan' }
+    let(:user) { User.new }
+
+    it "returns default user first name" do
+      expect(user.first_name).to eql(first_name)
+    end
+  end
+
+  context "default user last name " do
+    let (:first_name){ 'Petroff' }
+    let(:user) { User.new }
+
+    it "returns default user last name" do
+      expect(user.last_name).to eql(first_name)
+    end
+  end
+
+  context "user last name " do
+    let (:first_name){ 'Petya' }
+    let(:user) { User.new('Petya', 'Petroff') }
+
+    it "returns user last name" do
+      expect(user.first_name).to eql(first_name)
+    end
+  end
+
+  context "user last name " do
+    let (:last_name){ 'Petroff' }
+    let(:user) { User.new('Petya', 'Petroff') }
+
+    it "returns user last name" do
+      expect(user.last_name).to eql(last_name)
+    end
+  end
+
+  context "full name length" do
+    let (:count){ 12 }
+    let(:user) { User.new('Petya', 'Petroff') }
+
+    it "returns the number of characters in the full name " do
+      expect(user.full_name.length - 1).to eql(count)
+    end
+  end
+end
Index: test/users/user_test.rb
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>require 'bundler/setup'\nrequire 'minitest/autorun'\nrequire_relative '../../lib/users/user'\n\nclass UserTest < Minitest::Test\n  def test_positive_full_name_initialize\n     assert_equal('Ivan Petroff', User.new.full_name)\n  end\n\n  def test_positive_full_name\n    assert_equal('Ivan Ivanov', User.new('Ivan', 'Ivanov').full_name)\n  end\n\n  def test_positive_full_name_is_string\n    assert_instance_of(String, User.new('Ivan', 'Ivanov').full_name)\n  end\n\n  def test_default_first_name\n    user = User.new()\n    assert_equal(\"Ivan\", user.first_name)\n  end\n\n  def test_default_last_name\n    user = User.new()\n    assert_equal(\"Petroff\", user.last_name)\n  end\n\n  def test_first_name\n    user = User.new('Petya', 'Petroff')\n    assert_equal(\"Petya\", user.first_name)\n  end\n\n  def test_last_name\n    user = User.new('Petya', 'Petroff')\n    assert_equal(\"Petroff\", user.last_name)\n  end\n\n  def test_length_full_name\n    assert_equal(10, User.new('Ivan', 'Ivanov').full_name.length - 1)\n  end\nend\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/test/users/user_test.rb b/test/users/user_test.rb
--- a/test/users/user_test.rb	(revision 158b4c7559abb70b431fb7f309ca8e7389db2e03)
+++ b/test/users/user_test.rb	(date 1638174467470)
@@ -3,6 +3,7 @@
 require_relative '../../lib/users/user'
 
 class UserTest < Minitest::Test
+
   def test_positive_full_name_initialize
      assert_equal('Ivan Petroff', User.new.full_name)
   end
Index: test/registry/registry_test.rb
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>require 'bundler/setup'\nrequire 'minitest/autorun'\nrequire_relative '../../lib/registry/registry'\nrequire_relative '../../lib/registry/sha1_digester.rb'\n\nclass RegistryTest < Minitest::Test\n\n  def setup\n    @registry = DuplicateFilesRegistry.new\n    digester = Sha1Digester.new\n\n    data_path = File.expand_path('../../data/22.jpg', __dir__)\n    @digest = digester.digest(data_path)\n    @registry.add_file(@digest, data_path)\n\n    data_path = File.expand_path('../../data/3.jpg', __dir__)\n    @digest = digester.digest(data_path)\n    @registry.add_file(@digest, data_path)\n\n    data_path = File.expand_path('../../data/23.jpg', __dir__)\n    @digest = digester.digest(data_path)\n    @registry.add_file(@digest, data_path)\n\n  end\n\n  def test_registry_digests_is_array\n    assert_instance_of(Array,  @registry.digests)\n  end\n\n  def test_positive_registry_digests\n    assert_equal([\"c815eaafda365cf8b805fed05d6ccb04bddca917\", \"341170e3a4c2e5f0e1587de9d94e87be77c76ee8\"], @registry.digests)\n  end\n\n  def test_registry_grouped_files_is_array\n    assert_instance_of(Array,  @registry.grouped_files)\n  end\n\n  def test_registry_grouped_files\n    assert_equal([[\"C:/Users/Sad_7400/apps/tests/data/22.jpg\", \"C:/Users/Sad_7400/apps/tests/data/23.jpg\"], [\"C:/Users/Sad_7400/apps/tests/data/3.jpg\"]], @registry.grouped_files)\n  end\n\n  def test_registry_group_by_type_error\n    assert_raises do  @registry.group_by(@digest)\n    end\n  end\n\n  def test_duplicate_files_is_hash\n    assert_instance_of(Hash,  @registry.each{ |duplicates| puts duplicates })\n  end\n\n  def test_registry_each\n    assert_equal({\"c815eaafda365cf8b805fed05d6ccb04bddca917\"=>[\"C:/Users/Sad_7400/apps/tests/data/22.jpg\", \"C:/Users/Sad_7400/apps/tests/data/23.jpg\"], \"341170e3a4c2e5f0e1587de9d94e87be77c76ee8\"=>[\"C:/Users/Sad_7400/apps/tests/data/3.jpg\"]},  @registry.each{ |duplicates| puts duplicates })\n  end\n\n  def test_registry_empty\n    assert_equal(false ,  @registry.empty?)\n  end\n\n  def test_uniq_files_count\n    assert_equal(2 ,  @registry.uniq_files_count)\n  end\nend\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/test/registry/registry_test.rb b/test/registry/registry_test.rb
--- a/test/registry/registry_test.rb	(revision 158b4c7559abb70b431fb7f309ca8e7389db2e03)
+++ b/test/registry/registry_test.rb	(date 1638174630770)
@@ -1,62 +1,16 @@
 require 'bundler/setup'
 require 'minitest/autorun'
 require_relative '../../lib/registry/registry'
-require_relative '../../lib/registry/sha1_digester.rb'
+
 
 class RegistryTest < Minitest::Test
-
-  def setup
-    @registry = DuplicateFilesRegistry.new
-    digester = Sha1Digester.new
-
-    data_path = File.expand_path('../../data/22.jpg', __dir__)
-    @digest = digester.digest(data_path)
-    @registry.add_file(@digest, data_path)
-
-    data_path = File.expand_path('../../data/3.jpg', __dir__)
-    @digest = digester.digest(data_path)
-    @registry.add_file(@digest, data_path)
-
-    data_path = File.expand_path('../../data/23.jpg', __dir__)
-    @digest = digester.digest(data_path)
-    @registry.add_file(@digest, data_path)
+  def test_positive_full_name_initialize
 
-  end
+    registry = DuplicateFilesRegistry.new
 
-  def test_registry_digests_is_array
-    assert_instance_of(Array,  @registry.digests)
-  end
+    data_path = File.expand_path('data', __dir__)
+    digester = Digest::SHA1.hexdigest(data_path)
+    registry.add_file(digester, data_path)
 
-  def test_positive_registry_digests
-    assert_equal(["c815eaafda365cf8b805fed05d6ccb04bddca917", "341170e3a4c2e5f0e1587de9d94e87be77c76ee8"], @registry.digests)
-  end
-
-  def test_registry_grouped_files_is_array
-    assert_instance_of(Array,  @registry.grouped_files)
-  end
-
-  def test_registry_grouped_files
-    assert_equal([["C:/Users/Sad_7400/apps/tests/data/22.jpg", "C:/Users/Sad_7400/apps/tests/data/23.jpg"], ["C:/Users/Sad_7400/apps/tests/data/3.jpg"]], @registry.grouped_files)
-  end
-
-  def test_registry_group_by_type_error
-    assert_raises do  @registry.group_by(@digest)
-    end
-  end
-
-  def test_duplicate_files_is_hash
-    assert_instance_of(Hash,  @registry.each{ |duplicates| puts duplicates })
-  end
-
-  def test_registry_each
-    assert_equal({"c815eaafda365cf8b805fed05d6ccb04bddca917"=>["C:/Users/Sad_7400/apps/tests/data/22.jpg", "C:/Users/Sad_7400/apps/tests/data/23.jpg"], "341170e3a4c2e5f0e1587de9d94e87be77c76ee8"=>["C:/Users/Sad_7400/apps/tests/data/3.jpg"]},  @registry.each{ |duplicates| puts duplicates })
-  end
-
-  def test_registry_empty
-    assert_equal(false ,  @registry.empty?)
-  end
-
-  def test_uniq_files_count
-    assert_equal(2 ,  @registry.uniq_files_count)
   end
 end
Index: spec/registry/registry_spec.rb
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/spec/registry/registry_spec.rb b/spec/registry/registry_spec.rb
new file mode 100644
--- /dev/null	(date 1638174467437)
+++ b/spec/registry/registry_spec.rb	(date 1638174467437)
@@ -0,0 +1,67 @@
+require 'rspec'
+require './spec/spec_helper.rb'
+require_relative '../../lib/registry/registry'
+
+describe DuplicateFilesRegistry do
+  let(:registry) { DuplicateFilesRegistry.new }
+
+  before do
+    data_path = File.expand_path('../../data/', __dir__)
+    digester = Sha1Digester.new
+    file_names = Dir.entries(data_path).select {|f| !File.directory? f}
+
+    file_names.each  do |file_name|
+      full_file_name = File.join( data_path , file_name)
+      digest = digester.digest(full_file_name)
+      registry.add_file(digest, full_file_name)
+    end
+  end
+
+  context "digests" do
+    it "creates digest array" do
+      expect(registry.digests).to eql(["ecfacd866c94ed69bf8d810d70445adfa82858d2",
+                                       "c815eaafda365cf8b805fed05d6ccb04bddca917",
+                                       "341170e3a4c2e5f0e1587de9d94e87be77c76ee8",
+                                       "0281e9239cc465e66b197c71af1c46c116360d20"])
+    end
+  end
+
+  context "grouped_files" do
+    it "groups files into arrays by keysy" do
+      expect(registry.grouped_files).to eql([["C:/Users/Sad_7400/apps/tests/data/2.jpg"],
+                                             ["C:/Users/Sad_7400/apps/tests/data/22.jpg", "C:/Users/Sad_7400/apps/tests/data/222.jpg", "C:/Users/Sad_7400/apps/tests/data/23.jpg"],
+                                             ["C:/Users/Sad_7400/apps/tests/data/3.jpg", "C:/Users/Sad_7400/apps/tests/data/34.jpg"],
+                                             ["C:/Users/Sad_7400/apps/tests/data/4.jpg"]])
+    end
+  end
+
+  context "grouped_files(digest)" do
+    let(:digest) { "c815eaafda365cf8b805fed05d6ccb04bddca917" }
+    xit "outputs files with the corresponding digest" do
+      expect(registry.group_by(digest)).to raise_error
+    end
+  end
+
+  context "each" do
+    it "displays digests and files that correspond to them" do
+      expect(registry.each{ |duplicates| puts duplicates }).to eql({"ecfacd866c94ed69bf8d810d70445adfa82858d2"=>["C:/Users/Sad_7400/apps/tests/data/2.jpg"],
+                                                                    "c815eaafda365cf8b805fed05d6ccb04bddca917"=>["C:/Users/Sad_7400/apps/tests/data/22.jpg", "C:/Users/Sad_7400/apps/tests/data/222.jpg", "C:/Users/Sad_7400/apps/tests/data/23.jpg"],
+                                                                    "341170e3a4c2e5f0e1587de9d94e87be77c76ee8"=>["C:/Users/Sad_7400/apps/tests/data/3.jpg", "C:/Users/Sad_7400/apps/tests/data/34.jpg"],
+                                                                    "0281e9239cc465e66b197c71af1c46c116360d20"=>["C:/Users/Sad_7400/apps/tests/data/4.jpg"]})
+    end
+  end
+
+  context "empty?" do
+    let(:result) { false }
+    it "checks if case is empty" do
+      expect(registry.empty?).to eql(result)
+    end
+  end
+
+  context "uniq_files_count" do
+    let(:uniq_files_count) { 4 }
+    it "counts the number of unique filesy" do
+      expect(registry.uniq_files_count).to eql(uniq_files_count)
+    end
+  end
+end
Index: Gemfile.lock
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Gemfile.lock b/Gemfile.lock
new file mode 100644
--- /dev/null	(date 1638174467433)
+++ b/Gemfile.lock	(date 1638174467433)
@@ -0,0 +1,28 @@
+GEM
+  remote: https://rubygems.org/
+  specs:
+    diff-lcs (1.4.4)
+    minitest (5.14.4)
+    rspec (3.10.0)
+      rspec-core (~> 3.10.0)
+      rspec-expectations (~> 3.10.0)
+      rspec-mocks (~> 3.10.0)
+    rspec-core (3.10.1)
+      rspec-support (~> 3.10.0)
+    rspec-expectations (3.10.1)
+      diff-lcs (>= 1.2.0, < 2.0)
+      rspec-support (~> 3.10.0)
+    rspec-mocks (3.10.2)
+      diff-lcs (>= 1.2.0, < 2.0)
+      rspec-support (~> 3.10.0)
+    rspec-support (3.10.3)
+
+PLATFORMS
+  x64-mingw32
+
+DEPENDENCIES
+  minitest (~> 5.14.4)
+  rspec (~> 3.10.0)
+
+BUNDLED WITH
+   2.2.31
Index: spec/spec_helper.rb
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/spec/spec_helper.rb b/spec/spec_helper.rb
new file mode 100644
--- /dev/null	(date 1638174467440)
+++ b/spec/spec_helper.rb	(date 1638174467440)
@@ -0,0 +1,100 @@
+# This file was generated by the `rspec --init` command. Conventionally, all
+# specs live under a `spec` directory, which RSpec adds to the `$LOAD_PATH`.
+# The generated `.rspec` file contains `--require spec_helper` which will cause
+# this file to always be loaded, without a need to explicitly require it in any
+# files.
+#
+# Given that it is always loaded, you are encouraged to keep this file as
+# light-weight as possible. Requiring heavyweight dependencies from this file
+# will add to the boot time of your test suite on EVERY test run, even for an
+# individual file that may not need all of that loaded. Instead, consider making
+# a separate helper file that requires the additional dependencies and performs
+# the additional setup, and require it from the spec files that actually need
+# it.
+#
+# See http://rubydoc.info/gems/rspec-core/RSpec/Core/Configuration
+RSpec.configure do |config|
+  # rspec-expectations config goes here. You can use an alternate
+  # assertion/expectation library such as wrong or the stdlib/minitest
+  # assertions if you prefer.
+  config.expect_with :rspec do |expectations|
+    # This option will default to `true` in RSpec 4. It makes the `description`
+    # and `failure_message` of custom matchers include text for helper methods
+    # defined using `chain`, e.g.:
+    #     be_bigger_than(2).and_smaller_than(4).description
+    #     # => "be bigger than 2 and smaller than 4"
+    # ...rather than:
+    #     # => "be bigger than 2"
+    expectations.include_chain_clauses_in_custom_matcher_descriptions = true
+  end
+
+  # rspec-mocks config goes here. You can use an alternate test double
+  # library (such as bogus or mocha) by changing the `mock_with` option here.
+  config.mock_with :rspec do |mocks|
+    # Prevents you from mocking or stubbing a method that does not exist on
+    # a real object. This is generally recommended, and will default to
+    # `true` in RSpec 4.
+    mocks.verify_partial_doubles = true
+  end
+
+  # This option will default to `:apply_to_host_groups` in RSpec 4 (and will
+  # have no way to turn it off -- the option exists only for backwards
+  # compatibility in RSpec 3). It causes shared context metadata to be
+  # inherited by the metadata hash of host groups and examples, rather than
+  # triggering implicit auto-inclusion in groups with matching metadata.
+  config.shared_context_metadata_behavior = :apply_to_host_groups
+
+# The settings below are suggested to provide a good initial experience
+# with RSpec, but feel free to customize to your heart's content.
+=begin
+  # This allows you to limit a spec run to individual examples or groups
+  # you care about by tagging them with `:focus` metadata. When nothing
+  # is tagged with `:focus`, all examples get run. RSpec also provides
+  # aliases for `it`, `describe`, and `context` that include `:focus`
+  # metadata: `fit`, `fdescribe` and `fcontext`, respectively.
+  config.filter_run_when_matching :focus
+
+  # Allows RSpec to persist some state between runs in order to support
+  # the `--only-failures` and `--next-failure` CLI options. We recommend
+  # you configure your source control system to ignore this file.
+  config.example_status_persistence_file_path = "spec/examples.txt"
+
+  # Limits the available syntax to the non-monkey patched syntax that is
+  # recommended. For more details, see:
+  #   - http://rspec.info/blog/2012/06/rspecs-new-expectation-syntax/
+  #   - http://www.teaisaweso.me/blog/2013/05/27/rspecs-new-message-expectation-syntax/
+  #   - http://rspec.info/blog/2014/05/notable-changes-in-rspec-3/#zero-monkey-patching-mode
+  config.disable_monkey_patching!
+
+  # This setting enables warnings. It's recommended, but in some cases may
+  # be too noisy due to issues in dependencies.
+  config.warnings = true
+
+  # Many RSpec users commonly either run the entire suite or an individual
+  # file, and it's useful to allow more verbose output when running an
+  # individual spec file.
+  if config.files_to_run.one?
+    # Use the documentation formatter for detailed output,
+    # unless a formatter has already been configured
+    # (e.g. via a command-line flag).
+    config.default_formatter = "doc"
+  end
+
+  # Print the 10 slowest examples and example groups at the
+  # end of the spec run, to help surface which specs are running
+  # particularly slow.
+  config.profile_examples = 10
+
+  # Run specs in random order to surface order dependencies. If you find an
+  # order dependency and want to debug it, you can fix the order by providing
+  # the seed, which is printed after each run.
+  #     --seed 1234
+  config.order = :random
+
+  # Seed global randomization in this process using the `--seed` CLI option.
+  # Setting this allows you to use `--seed` to deterministically reproduce
+  # test failures related to randomization by passing the same `--seed` value
+  # as the one that triggered the failure.
+  Kernel.srand config.seed
+=end
+end
